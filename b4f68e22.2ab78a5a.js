(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{124:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(2),o=n(6),r=(n(0),n(139)),s=(n(141),{id:"js20",title:"Promises",sidebar_label:"Promises"}),i={id:"jsbootcamp/js20",title:"Promises",description:"Intro to Promises",source:"@site/docs/jsbootcamp/js20.mdx",permalink:"/notebook/docs/jsbootcamp/js20",editUrl:"https://github.com/gsavitha95/notebook/tree/master/notes-website/docs/jsbootcamp/js20.mdx",sidebar_label:"Promises",sidebar:"someSidebar",previous:{title:"Callback Hell",permalink:"/notebook/docs/jsbootcamp/js19"},next:{title:"Making HTTP Requests",permalink:"/notebook/docs/jsbootcamp/js15"}},c=[{value:"Intro to Promises",id:"intro-to-promises",children:[{value:"Creating a promise",id:"creating-a-promise",children:[]},{value:"Interacting with promises",id:"interacting-with-promises",children:[]},{value:"Returning Promises from functions",id:"returning-promises-from-functions",children:[]}]},{value:"Resolving or rejecting with values",id:"resolving-or-rejecting-with-values",children:[]},{value:"Promise chaining",id:"promise-chaining",children:[]},{value:"Exercise",id:"exercise",children:[]}],l={rightToc:c};function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"intro-to-promises"},"Intro to Promises"),Object(r.b)("p",null,"A promise is an ",Object(r.b)("strong",{parentName:"p"},"object")," representing the ",Object(r.b)("strong",{parentName:"p"},"eventual completion(usually which takes time) or failure of an asynchronous operation"),"."),Object(r.b)("p",null,"Promises allow us to write an asynchronous code that is much easier to read and understand. Its much flatter, its not so nested."),Object(r.b)("p",null,"The prev callback hell example code rewritten to promises looks like this"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'moveXPromise(btn, 100, 000)\n  .then(() => moveXPromise(btn, 100, 1000))\n  .then(() => moveXPromise(btn, 200, 1000))\n  .then(() => moveXPromise(btn, 300, 1000))\n  .then(() => moveXPromise(btn, 500, 1000))\n  .then(() => moveXPromise(btn, 500, 1000))\n  .catch((position) => {\n    alert("Cannot move further");\n  });\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Promises")," : ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("em",{parentName:"strong"},"A pattern"))," to write async code."),Object(r.b)("p",null,"When we work with promises there are only 2 different things we need to understand"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"How you create a promise. How you could create a function that returns a promise."),Object(r.b)("li",{parentName:"ol"},"How you consume and interact with the promises (which we do all the time, even if we are not writing promises ourselves. we might make a req from a library or using a library like axioms )")),Object(r.b)("p",null,"So promise is a way of promising a value that you may not have at the moment. Its a guarantee or supposed guarantee of an eventual value."),Object(r.b)("p",null,"If you are making a HTTP request it could take time and may never return the value. It might be a failure or success and you might get some data backfrom an API but it takes time. ",Object(r.b)("strong",{parentName:"p"},"So the object that is returned in the meantime is a promise")," and we attach a callback to it."),Object(r.b)("div",{className:"admonition admonition-important alert alert--info"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"important")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"A promise is a returned object to which you attach callbacks, instead of passing callbacks into a function."))),Object(r.b)("h3",{id:"creating-a-promise"},"Creating a promise"),Object(r.b)("p",null,"Syntax:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const createPromise = new Promise((resolve, reject) => {});\n")),Object(r.b)("p",null,"resolve and reject are actually functions. At any point inside of the function, if we call resolve , promise will be resolved. If we call reject, promise will be rejected"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const willGetYouADog = new Promise((resolve, reject) => {});\n/*[[PromiseStatus]] : "pending"\n[[PromiseValue]] : undefined*/\n')),Object(r.b)("p",null,"pending status is what we see frequently when a promise is first started"),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"If you dont resolve or reject a promise, its status will be pending and its value will be undefined\n[","[PromiseStatus]",'] : "pending"\n[',"[PromiseValue]","] : undefined"))),Object(r.b)("p",null,"If you simply call reject"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const willGetYouADog = new Promise((resolve, reject) => {\n  reject();\n});\n//We get an error that we didnt catch (in console), Error : Uncaught in promise\n//[[Promise Status]]  : rejected\n//[[Promise Value]] : undefined\n\n// Instead if we resolve:\n\nconst willGetYouADog = new Promise((resolve, reject) => {\n  resolve();\n});\n//No error\n//[[Promise Status]]  : resolved\n//[[Promise Value]] : undefined\n")),Object(r.b)("p",null,"Lets write a logic for a promise, which randomly resolves or rejects a promise."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const willGetYouADog = new Promise((resolve, reject) => {\n  const rand = Math.random();\n  if (rand < 0.5) resolve();\n  else reject();\n});\n")),Object(r.b)("p",null,"This is the first part of how we create a promise. The extremely important part is how we interact with the promise when it is rejected and when it is resolved. This is where we use ",Object(r.b)("strong",{parentName:"p"},".then() & .catch()")," methods."),Object(r.b)("h3",{id:"interacting-with-promises"},"Interacting with promises"),Object(r.b)("p",null,"When a promise is ",Object(r.b)("strong",{parentName:"p"},"resolved")," it automatically ",Object(r.b)("strong",{parentName:"p"},"runs .then()")," and when a promise is ",Object(r.b)("strong",{parentName:"p"},"rejected")," it automatically ",Object(r.b)("strong",{parentName:"p"},"runs .catch()")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const willGetYouADog = new Promise((resolve, reject) => {\n  const rand = Math.random();\n  if (rand < 0.5) resolve();\n  else reject();\n});\nwillGetYouADog.then(() => {\n  console.log("Yay we got a dog!");\n});\nwillGetYouADog.catch(() => {\n  console.log("No dog :(");\n});\n')),Object(r.b)("p",null,"If we do neither, status remains pending until its resolved or rejected"),Object(r.b)("h3",{id:"returning-promises-from-functions"},"Returning Promises from functions"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const makeADogPromise = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const rand = Math.random();\n      if (rand < 0.5) resolve();\n      else reject();\n    }, 5000);\n  });\n};\n\n//we can actually chain the methods instead of creating another promise by calling makeADogPromise.catch()\n// if we create 2 seperate promises we may not resolve or we may not reject. We can have different values\n//but instead if we chain, we get around that problem\n// we will not be wasting any extra space by creating a new variable(d = make .. d.then() , d.catch()) by chaining and also we wont be creating an extra reference to a promise again.\n//only one of the other will run if we do  chaining\nmakeADogPromise\n  .then(() => {\n    console.log("Yay we got a dog!");\n  })\n  .catch(() => {\n    console.log("No dog :(");\n  });\n')),Object(r.b)("p",null,"Returning a promise from functions is a very common pattern."),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'axios.get("/reddit.com").then().catch();\n')),Object(r.b)("p",null,"Axios is returning a promise by executing the get() function"),Object(r.b)("hr",null),Object(r.b)("h2",{id:"resolving-or-rejecting-with-values"},"Resolving or rejecting with values"),Object(r.b)("p",null,"When you resolve or reject a promise you can reject or resolve with a value and ",Object(r.b)("strong",{parentName:"p"},"you have access to that value in callback that you pass into then or catch")),Object(r.b)("p",null,"An example to check if a url exists in the object and pass the data and status code based on the user's request"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const fakeRequest = (url) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const pages = {\n        "/users": [\n          { id: 1, username: "bob" },\n          { id: 5, username: "clarke" },\n        ],\n        "/about": "This is about page",\n      };\n      const data = pages[url];\n      if (data) resolve({ status: 200, data: data });\n      else reject({ status: 404 });\n    }, 3000);\n  });\n};\n//runs then()\nfakeRequest("/users")\n  .then((res) => {\n    console.log("Status code", res.status);\n    console.log("Data", res.data);\n    console.log("Request worked");\n  })\n  .catch((res) => {\n    console.log(res.status);\n    console.log("Request failed");\n  });\n// runs catch(), coz we dont have /dogs url\nfakeRequest("/dogs")\n  .then((res) => {\n    console.log("Status code", res.status);\n    console.log("Data", res.data);\n    console.log("Request worked");\n  })\n  .catch((res) => {\n    console.log(res.status);\n    console.log("Request failed");\n  });\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"promise-chaining"},"Promise chaining"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const fakeRequest = (url) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const pages = {\n        "/users": [\n          { id: 1, username: "Bilbo" },\n          { id: 5, username: "Esmerelda" },\n        ],\n        "/users/1": {\n          id: 1,\n          username: "Bilbo",\n          upvotes: 360,\n          city: "Lisbon",\n          topPostId: 454321,\n        },\n        "/users/5": {\n          id: 5,\n          username: "Esmerelda",\n          upvotes: 571,\n          city: "Honolulu",\n        },\n        "/posts/454321": {\n          id: 454321,\n          title: "Ladies & Gentlemen, may I introduce my pet pig, Hamlet",\n        },\n        "/about": "This is the about page!",\n      };\n      const data = pages[url];\n      if (data) {\n        resolve({ status: 200, data }); //resolve with a value!\n      } else {\n        reject({ status: 404 }); //reject with a value!\n      }\n    }, 1000);\n  });\n};\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'fakeRequest("/users").then((res) => {\n  const id = res.data[0].id;\n  //make another request with id, we cant do do it outside of this scope, coz we dont have access to id outside\n  //nest it here\n  fakeRequest(`/users/${id}`).then((res) => {\n    //access the post\n    const postId = res.data.topPostId;\n    //make a request to that post -> this is a 3rd request that is dependent upon 2nd and 2nd is dependent upon 1st\n    fakeRequest(`/posts/${postId}`).then((res) => {\n      console.log(res);\n    });\n  });\n});\n')),Object(r.b)("p",null,"This doesnt look much better than what we saw in callback hell and also we dont have catches yet, if we have catches for each .then() it would look more messier. We have much better way for rewriting all of this"),Object(r.b)("p",null,"What we can do is ",Object(r.b)("strong",{parentName:"p"},"in the callback of .then() return a new promise"),", we can call callback of .then() of next request immediately in the same level, we dont need to nest our .then(). We can continue to chain .then() as long as we return promises in each callback."),Object(r.b)("p",null,"Syntax:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),".then(()=>{\n  return promise;\n})\n.then(()=>{\n  return promise;\n  })\n.then(()=>{\n  return promise;\n})\n")),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The second .then() runs only if first .then() is resolved, third .then() runs only if second is resolved."))),Object(r.b)("p",null,"After nesting"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'fakeRequest("/users")\n  .then((res) => {\n    console.log(res);\n    const id = res.data[0].id;\n    return fakeRequest(`/users/${id}`);\n  })\n  .then((res) => {\n    console.log(res);\n    const postId = res.data.topPostId;\n    return fakeRequest(`/posts/${postId}`);\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log("OH NO!", err);\n  });\n')),Object(r.b)("p",null,"So here is the magical part, ",Object(r.b)("strong",{parentName:"p"},"We only need one .catch()"),". If any of the promise is screwed up, the catch will run immediately, we dont need to write catch for each promise. Its like a catch all :D"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'// ************************************************\n// ATTEMPT 2 (deliberate error to illustrate CATCH)\n// ************************************************\nfakeRequest("/users")\n  .then((res) => {\n    console.log(res);\n    const id = res.data[0].id;\n    return fakeRequest(`/useALSKDJrs/${id}`); //INVALID URL, CATCH WILL RUN!\n  })\n  .then((res) => {\n    console.log(res);\n    const postId = res.data.topPostId;\n    return fakeRequest(`/posts/${postId}`);\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log("OH NO!", err);\n  });\n')),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"If we screw up any promise in between, the promises after it wont be executed."))),Object(r.b)("p",null,"Here in the above example 1st promise is ran, second is screwed up .. so only resolved output of 1st one is shown"),Object(r.b)("p",null,"Using chaining, we can have multiple asynchronous actions that we want to happen one after the other(not simultaneously)."),Object(r.b)("h2",{id:"exercise"},"Exercise"),Object(r.b)("p",null,"Refactoring our prev callback hell example with promises."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const moveX = (element, amount, delay) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const bodyBoundary = document.body.clientWidth;\n      const elRight = element.getBoundingClientRect().right;\n      const currLeft = element.getBoundingClientRect().left;\n      if (elRight + amount > bodyBoundary) {\n        reject(bodyBoundary, elRight, amount);\n      } else {\n        element.style.transform = `translateX(${currLeft + amount}px)`;\n        resolve();\n      }\n    }, delay);\n  });\n};\n\nmoveX(btn, 300, 1000)\n  .then(() => {\n    return moveX(btn, 300, 1000);\n  })\n  .then(() => {\n    return moveX(btn, 300, 1000);\n  })\n  .then(() => {\n    return moveX(btn, 300, 1000);\n  })\n  .then(() => {\n    return moveX(btn, 300, 1000);\n  })\n  .catch(() => {\n    console.log("Out of space, cannot move");\n  });\n')),Object(r.b)("p",null,"We can still shorten this up using implicit returns of arrow functions"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"moveXPromise(btn, 100, 000)\n  .then(() => moveXPromise(btn, 300, 1000))\n  .then(() => moveXPromise(btn, 300, 1000))\n  .then(() => moveXPromise(btn, 300, 1000))\n  .then(() => moveXPromise(btn, 300, 1000))\n  .then(() => moveXPromise(btn, 300, 1000))\n  .catch(({ bodyBoundary, elRight, amount }) => {\n    console.log(`Body is ${bodyBoundary} px width`);\n    console.log(`Element is at ${elRight} px, ${amount} px is too large`);\n  });\n")))}b.isMDXComponent=!0},139:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),b=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=b(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=b(n),p=a,d=u["".concat(s,".").concat(p)]||u[p]||m[p]||r;return n?o.a.createElement(d,i(i({ref:t},l),{},{components:n})):o.a.createElement(d,i({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},140:function(e,t,n){"use strict";var a=n(0),o=n(34);t.a=function(){return Object(a.useContext)(o.a)}},141:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(140);function o(e){const{siteConfig:t}=Object(a.a)(),{baseUrl:n="/"}=t||{};if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?n+e.slice(1):n+e}}}]);