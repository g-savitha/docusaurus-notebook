(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{130:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var a=t(2),o=t(6),r=(t(0),t(139)),i={id:"js16",title:"Async and Await",sidebar_label:"Async and Await"},c={id:"jsbootcamp/js16",title:"Async and Await",description:"Introduction",source:"@site/docs/jsbootcamp/js16.md",permalink:"/notebook/docs/jsbootcamp/js16",editUrl:"https://github.com/gsavitha95/notebook/tree/master/notes-website/docs/jsbootcamp/js16.md",sidebar_label:"Async and Await",sidebar:"someSidebar",previous:{title:"Making HTTP Requests",permalink:"/notebook/docs/jsbootcamp/js15"},next:{title:"Prototypes, classes & The New operator",permalink:"/notebook/docs/jsbootcamp/js17"}},s=[{value:"Introduction",id:"introduction",children:[{value:"async",id:"async",children:[]},{value:"await",id:"await",children:[]}]},{value:"Error handling in async functions",id:"error-handling-in-async-functions",children:[]},{value:"Multiple awaits",id:"multiple-awaits",children:[]},{value:"Parallel Vs. Sequential requests",id:"parallel-vs-sequential-requests",children:[]},{value:"Promise.all",id:"promiseall",children:[]}],l={rightToc:s};function p(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Pre reqs : Promises")),Object(r.b)("p",null,"Main idea behind async functions:"),Object(r.b)("p",null,"To work with async functions, we need to use callbacks or promises. Async and await makes our work easier and cleaner with promises and create synchronous looking asynchronous code"),Object(r.b)("p",null,"The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'function resolveAfter2Seconds() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve("resolved");\n    }, 2000);\n  });\n}\n\nasync function asyncCall() {\n  console.log("calling");\n  const result = await resolveAfter2Seconds();\n  console.log(result);\n  // expected output: \'resolved\'\n}\n\nasyncCall();\n')),Object(r.b)("h3",{id:"async"},"async"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Async functions always return a promise"),Object(r.b)("li",{parentName:"ul"},"If the function returns a value, the promise will be resolved with that value."),Object(r.b)("li",{parentName:"ul"},"If the function throws an exception, the promise will be rejected.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"async function hello() {\n  return \"hello world\";\n}\nhello(); // Promise {resolved :'hello world'}\n\nasync function ohNo() {\n  throw new Error(\"oh no!\");\n  ohNo(); //Promise {rejected : Error:  'oh no!'}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'async function greet() {\n  return "Hello!!";\n}\n\ngreet().then((val) => {\n  console.log("Promise is resolved with :", val);\n});\n//throw an exception  or an errorto reject a promise\nasync function add(x, y) {\n  if (typeof x !== "number" || typeof y !== "number")\n    throw "X and Y must be numbers";\n  return x + y;\n}\n\nadd("e", "r")\n  .then((val) => {\n    console.log("Promise resolved with", val);\n  })\n  .catch((err) => {\n    console.log("Promise rejected with", err);\n  });\n')),Object(r.b)("p",null,"Same code if we had to write with promises:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'function add(x, y) {\n  return new Promise((resolve, reject) => {\n    if (typeof x !== "number" || typeof y !== "number")\n      reject("X and Y must be numbers");\n  });\n  resolve(x + y);\n}\n')),Object(r.b)("h3",{id:"await"},"await"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"We can only use the await keyword inside of function declared as async."),Object(r.b)("li",{parentName:"ul"},"await will pause the execution of the function, waiting for the promise to be resolved. Without having to use .next() we can run code after an async peration.")),Object(r.b)("p",null,"Before await:"),Object(r.b)("p",null,"We had to manually resolve the promise."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'//get the list of planets\n\nfunction getPlanets() {\n  return axios.get("https://swapi.dev/api/planets/");\n}\n\ngetPlanets.then((res) => {\n  console.log("Planets data", res.data);\n});\n')),Object(r.b)("p",null,"Await:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'async function getPlanets() {\n  const res = await axios.get("https://swapi.dev/api/planets/"); //await returns a promise capture it\n  console.log(res.data);\n}\n')),Object(r.b)("p",null,"By putting await infront of request, js will wait until the promise is resolved, it will not move on."),Object(r.b)("hr",null),Object(r.b)("h2",{id:"error-handling-in-async-functions"},"Error handling in async functions"),Object(r.b)("p",null,"Lets say we had a n/w failure or if the URL is invalid, promise gets rejected, and we are not catching it."),Object(r.b)("p",null,"We have a couple of options to resolve this"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"chain .catch() to our method"),Object(r.b)("li",{parentName:"ol"},"Nest our logic which you think might throw an error in try and catch block.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'//1st way\nasync function getPlanets() {\n  const res = await axios.get("https://swapi.dev/api/planets/jknkl"); //await returns a promise capture it\n  console.log(res.data);\n}\n\ngetPlanets().catch((err) => {\n  console.log("In catch!", err);\n});\n\n//2nd way\nasync function getPlanets() {\n  try {\n    const res = await axios.get("https://swapi.dev/api/planets/jknkl");\n    console.log(res.data);\n  } catch (error) {\n    console.log("In catch!", error);\n  }\n}\n')),Object(r.b)("p",null,"We get the same behaviour, but these two are technically different. Using 1st way, we can catch multiple functions that are returning promises and .catch() will run for any of the reason when promise gets rejected . 2nd way, catches errors only within that async function."),Object(r.b)("p",null,"using .catch() is more like a backup to catch multiple potential errors. try and catch is more specific to what we're trying to do and we can be more detailed how we handle it."),Object(r.b)("hr",null),Object(r.b)("h2",{id:"multiple-awaits"},"Multiple awaits"),Object(r.b)("p",null,"Without using .then() 's from our previous code from promises section. lets refactor this using await"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'const moveX = (element, amount, delay) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const bodyBoundary = document.body.clientWidth;\n      const elRight = element.getBoundingClientRect().right;\n      const currLeft = element.getBoundingClientRect().left;\n      if (elRight + amount > bodyBoundary) {\n        reject(bodyBoundary, elRight, amount);\n      } else {\n        element.style.transform = `translateX(${currLeft + amount}px)`;\n        resolve();\n      }\n    }, delay);\n  });\n};\nconst btn = document.querySelector("button");\n\nasync function animateRight(el) {\n  await moveX(el, 100, 1000); //we can await this function since it returns a promise\n  moveX(el, 100, 1000);\n}\n')),Object(r.b)("p",null,"Once we hit the end lets animate back to left"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'//move a little more right\nasync function animateRight(el, amt) {\n  await moveX(el, amt, 1000); //we can await this function since it returns a promise\n  await moveX(el, amt, 1000);\n  await moveX(el, amt, 1000);\n  await moveX(el, amt, 1000);\n  await moveX(el, amt, 1000);\n  await moveX(el, amt, 1000);\n  await moveX(el, amt, 1000);\n}\n\nanimateRight(btn, 100).catch((err) => {\n  console.log("All done");\n  animateRight(btn, -100);\n});\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"parallel-vs-sequential-requests"},"Parallel Vs. Sequential requests"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Sequential Requests:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'async function get3Pokemon() {\n  const poke1 = await axios.get("https://pokeapi.co/api/v2/pokemon/1");\n  const poke2 = await axios.get("https://pokeapi.co/api/v2/pokemon/2");\n  const poke3 = await axios.get("https://pokeapi.co/api/v2/pokemon/3");\n  console.log(poke1.data);\n  console.log(poke2.data);\n  console.log(poke3.data);\n}\nget3Pokemon();\n')),Object(r.b)("p",null,"Here poke1 is a response from promise."),Object(r.b)("p",null,"Its important to know all these functions are happening in sequence. poke1 executes and returns first then poke2 and next poke3. (We dont need these to be in sequence, because these aint depending on each other.)"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Parallel Requests:"),"\nWe are not going to await while sending off these requests"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'async function get3Pokemon() {\n  // all requests are sent at same time\n  const prom1 = axios.get("https://pokeapi.co/api/v2/pokemon/1");\n  const prom2 = axios.get("https://pokeapi.co/api/v2/pokemon/2");\n  const prom3 = axios.get("https://pokeapi.co/api/v2/pokemon/3");\n  console.log(prom1); //pending -> probably all 3 are pending infact\n  const poke1 = await prom1; //await the response that comes back\n  const poke2 = await prom2;\n  const poke3 = await prom3;\n  console.log(prom1); //resolved\n  console.log(poke1.data);\n  console.log(poke2.data);\n  console.log(poke3.data);\n}\nget3Pokemon();\n')),Object(r.b)("p",null,"Here poke1 is a promise. All promises are ran first, initially they all are in pending state and all requests are sent at once over here. We are not waiting for one to complete and get resolved. first we request all at once, then we reolve them later."),Object(r.b)("p",null,"To get a clear understanding try the below code for a visual representation"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'//SEQUENTIAL REQUESTS\nfunction changeBodyColor(color, delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      document.body.style.backgroundColor = color;\n      resolve();\n    }, delay);\n  });\n}\nasync function lightShow() {\n  await changeBodyColor("teal", 1000);\n  await changeBodyColor("pink", 1000);\n  await changeBodyColor("indigo", 1000);\n  await changeBodyColor("violet", 1000);\n}\n\nlightShow();\n//teal, pink, indigo, violet colors are shown one after the other with 1 sec gap -> total 4+ sec\n\n//PARALLEL REQUESTS\nasync function lightShow() {\n  const p1 = changeBodyColor("teal", 1000);\n  const p2 = changeBodyColor("pink", 1000);\n  const p3 = changeBodyColor("indigo", 1000);\n  const p4 = changeBodyColor("violet", 1000);\n  await p1;\n  await p2;\n  await p3;\n  await p4;\n}\n//1sec.. we go straight to violet, we dont see those pauses along the way -> total 1 sec\n')),Object(r.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"If you dont need your requests in sequence, do it in parallel"))),Object(r.b)("hr",null),Object(r.b)("h2",{id:"promiseall"},"Promise.all"),Object(r.b)("p",null,"Refactoring with promise.all\nPromise.all accepts an array of promises"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'async function get3Pokemon() {\n  const prom1 = axios.get("https://pokeapi.co/api/v2/pokemon/1");\n  const prom2 = axios.get("https://pokeapi.co/api/v2/pokemon/2");\n  const prom3 = axios.get("https://pokeapi.co/api/v2/pokemon/3");\n  const results = await Promise.all([prom1, prom2, prom3]);\n  //this line will only run when all of the promises are resolved\n  printPokemon(results);\n}\nfunction printPokemon(results) {\n  for (let pokemon of results) {\n    console.log(pokemon.data.name);\n  }\n}\nget3Pokemon();\n')))}p.isMDXComponent=!0},139:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return d}));var a=t(0),o=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=o.a.createContext({}),p=function(e){var n=o.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=p(e.components);return o.a.createElement(l.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},m=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=a,d=u["".concat(i,".").concat(m)]||u[m]||b[m]||r;return t?o.a.createElement(d,c(c({ref:n},l),{},{components:t})):o.a.createElement(d,c({ref:n},l))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<r;l++)i[l]=t[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);