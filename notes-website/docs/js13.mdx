---
id: js13
title: Communication With Events
sidebar_label: Event handling
---

import useBaseUrl from "@docusaurus/useBaseUrl";

## Intro to DOM Events

**Events** - Responding to user inputs and actions

**Types of events**:

<img alt="Docusaurus with Keytar" src={useBaseUrl("assets/eventsintro.png")} />

:::note
All events follow a similar pattern
:::

**Pattern**:

| The thing | Event type  | Code to run            |
| --------- | ----------- | ---------------------- |
| button    | click       | change the color       |
| input     | hits return | get the search results |
| image     | mouseover   | display img caption    |

> for more info visit [MDN Event reference](https://developer.mozilla.org/en-US/docs/Web/Events)

## 2 ways not to add events

Here we will explore 2 different syntaxes which we should not use

> all events start with `on` word.
> `onEventName = doSomething`

1. First type actually involves inline html scripting, which is not recommended. It just clutters the markup.

```html
<button onmouseover="alert('You hovered over me!')">click me!</button>
<form>
  <input
    type="range"
    min="50"
    max="100"
    onclick="console.log('clicked the input')"
  />
</form>
```

2. We first select an element in Javascript and then do inline html scripting

```javascript
<button id="clicker">CLicker!</button>;

const clicker = document.querySelector("#clicker");

clicker.onclick = function () {
  console.log("You clicked me");
};
clicker.ondblclick = function () {
  console.log("Double click");
};

clicker.onclick = function () {
  alert("hello");
};
//now we lost the previous data.
//Onclick is considered just like any other property
```

if you want to have multiple events to a single element use `addEventListener`

---

## addEventListener

Specify the event type and a callback to run

```javascript
//Syntax:
btn.addEventListener("eventType", function () {}); // the function will execute when the event occurs
```

> we dont use onclick or onmouseover here. we just pass click and mouseover as parameters to addEventListener function

```javascript
const button = document.querySelector("h1");
button.addEventListener("click", () => {
  alert("You clicked");
});

button.addEventListener("click", () => {
  console.log("Output in console");
}); // we get both things as output for one event. one inconsole and other as alert
button.addEventListener("mouseover", function () {
  button.innerText = "Dont hover on me";
}); // we are permanently changing the innerText, the text doesnt go back to its prev state
// to get the text to its prev state. there is another event called `mouseout` use that.
button.addEventListener("mouseout", function () {
  button.innerText = "CLick me!";
}); // bnow text changes back to prev state
```

addEventListener() is great, because it is just one method and it will attach to any type of event listener you want(click, double click, mouseover etc...)

:::note
if you see `button.onclick` property, it is not attached to anything. It returns null as output
:::

:::important
dont use arrow functions as call backs, because sometimes we want to access `this` inside the function. and arrow functions doesnt do well with `this`
:::

---

## Events on Multiple Elements

This is the important topic of event handling. We know how to add multiple events to a single element. how about multiple elements having a single event? How do we take every button on page and add a click event?

1. select a group of items u want to add events to
2. loop over them and add eventlistener to each

> `this` refers to individual object onto which we are listening over when adding multiple events

Exercise:

```javascript

<body>
<h1>Pick a color</h1>
<section class="boxes" id="container"></section>
<script src="app.js"></script>
</body>
//CSS file
#container {
  display: flex;
  justify-content: center;
  align-items: center;
}
.box {
  width: 200px;
  height: 200px;
}
h1 {
  text-align: center;
}

const colors = ["red","yellow","orange","green","blue","purple","indigo","violet"];
const boxes = document.querySelector("#container");
const heading = document.querySelector("h1");
const pickAColor = function () {
  console.log(this);
  heading.style.color = this.style.backgroundColor;
};

for (let color of colors) {
  const box = document.createElement("div");
  box.style.backgroundColor = color;
  box.classList.add("box");
  boxes.appendChild(box);
  box.addEventListener("click", pickAColor);
}

```

:::important
So when the function pickAColor is called, ie., when we click on a box, we are never executing pickAColor ourselves, its being called for us. An Event object is passed to it

`Event object` is automatically called every time we are not capturing it
:::

---

## Event Object

Contains information about a particular event

```javascript
const pickAColor = function (evt) {
  console.log(evt); //MouseEvent Object is returned
};
```

```javascript
document.body.addEventListener("keypress", function (e) {
  console.log(e);
}); //RT: KeyboardEvent
```

**KeyboardEvent** - Conatins info about the key we pressed and othe useful info about keys

---

## Key Events

There are atleast 3 types of keyevents.

**Keyup, keydown, keypress**

### keydown

A Key has been pressed.

When u hold or press any key it is considered as keydown event.

:::note
keydown runs for any potential keys whether they actually change the input or not
:::

All key presses are considered as keydown events.
eg: alt/option, cmd, ctrl, caps, all alphabets, space, shift, tab etc.

```html
<input type="text" id="username" placeholder="username" type="text" />
```

```javascript
const username = document.querySelector("#username");
//we would want event object, because it contain info about which key is pressed
username.addEventListener("keydown", function (e) {
  console.log("KEY DOWN");
});
```

### keyup

A key has been released.

For all keys, first a keydown event is fired followed by a keyup.

:::note
keyup only occurs when u release a key
:::

```javascript
const username = document.querySelector("#username");

username.addEventListener("keydown", function (e) {
  console.log("KEY DOWN");
});
username.addEventListener("keyup", function (e) {
  console.log("KEY UP");
});
```

### keypress

A key that normally produces a character value has been pressed.
If the key is not a modifier key, the keypress event is sent

:::caution
This event is obsolete and differs from browser to browser, better not to use it much
:::

:::note
**Special cases**:
Some keys toggle the state of an indicator light; these include keys such as `Caps Lock`, `Num Lock`, and `Scroll Lock`. On Windows and Linux, these keys dispatch only the `keydown and keyup events`. However, a limitation of the macOS event model causes `Caps Lock` to dispatch only the `keydown` event
:::

When ypu type a key K in the input. The order of key sequenes would be `Keydown, keypress, keyup`

When you press something like shift we only get keydown and keyup

Capital letter -> Shift + Letter -> KeyDown(2) , keypress, keyup(2) -> keydown and keyup for both shift and letter

:::note
keypress only works when we have changing input. like aplhabets, doesnt work with arrows, caps, shift, tab, cmd etc.

But when you hit return, it is considered as a keypress
:::

### Exercise

Lets make a todo list

```html
<h1>Shopping list</h1>
<input type="text" name="" id="addItem" placeholder="add items in your list" />
<ul id="items"></ul>
```

```javascript
const input = document.querySelector("#addItem");
const ulItems = document.querySelector("#items");

input.addEventListener("keypress", function (e) {
  // doesnt allow spaces in the beginning
  if (e.which === 32 && !this.value.length) {
    e.preventDefault();
  }
  if (e.key === "Enter") {
    if (!this.value) return;
    const item = document.createElement("li");
    item.innerText = this.value;
    console.log(item);
    this.value = "";
    ulItems.appendChild(item);
  }
});
```

> For more on events [WEBApi - MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

---

## FormEvents & preventDefault

When we press submit, we get navigated to other page or the page gets refreshed if we dont specify any url in action.

Lets say we want to stop the form from getting refreshed when we submit.

capture the submit event and stop it from its default behaviour.

```html
<form id="signup">
  <input type="text" placeholder="credit card" id="cc" />
  <label>
    I agree to T&C
    <input type="checkbox" id="terms" />
  </label>
  <select id="veggies">
    <option value="brinjal">Brinjal</option>
    <option value="tomato">Tomato</option>
    <option value="onion">Onion</option>
  </select>
  <button type="submit">Submit</button>
</form>
```

### preventDefault

Default behaviour is prevented

```javascript
const form = document.querySelector("#signup");
form.addEventListener("submit", function (e) {
  e.preventDefault(); //when this is executed default behaviour is prevented
});
```

Now this leaves us free to now extract data from the submit event. If we wanted all data at once and send it to an api using AJAX or using a client side request, we can do that. We have flexibility to do something woth the data and we can still capture the submit event. What's nice about doing this way as opposed to capturing each input as it changes every single time is we dont need to attach a bunch of event listeners for every input, by adding a submit event listener there's just one event we are waiting for, we tell it not to behave, normally it behaves and then we can extract our data in that function.

```javascript
const creditCardInput = document.querySelector("#cc");
const termszcheckBox = document.querySelector("#terms");
const veggiesSelect = document.querySelector("#veggies");
const form = document.querySelector("#signup");
form.addEventListener("submit", function (e) {
  console.log("cc", creditCardInput.value); //cc 12343434535
  console.log("terms", termszcheckBox.checked); // terms true
  // we get the value from value attribute, eg: we get brinjal as output instead of Brinjal
  console.log("veggiesSelect", veggiesSelect.value); //veggiesSelect tomato
  e.preventDefault();
});
```

We are accessing data from the form. After accessing these values , we can generally send form data to DB or append something to page using form data
We can put preventDefault() at the top of the function, it still works the same

---

## input and change Events

### input

This event is triggered whenever an input changes .We can actually listen to all 3 above inputs(textbox, checkbox and select) at once using a single event type.

Our goal is to create a datastructure which automatically updates whenever a user enters value in input, instead of waitiing for user to submit(like from the above section)

```javascript
creditCardInput.addEventListener("input", (e) => {
  console.log("CC Changed", e); // the event is triggered whenever we type something in the input box
});
```

Storing value to an object as soon as user changes the input. These events trigger before user clicks submit.

```javascript
const formData = {};
creditCardInput.addEventListener("input", (e) => {
  console.log("CC Changed", e);
  //formData['cc'] = creditCardInput.value; -> hard coding. instead use event object properties to get value
  formData["cc"] = e.target.value;
});
veggiesSelect.addEventListener("input", (e) => {
  console.log("veggie change", e);
  formData["veggie"] = e.target.value;
});
termszcheckBox.addEventListener("input", (e) => {
  console.log("terms changed", e);
  formData["terms"] = e.target.checked;
});
```

Refactor the above code.
add a `name` attribute to each html input

```html
<input type="text" placeholder="credit card" id="cc" name="creditcard" />
<label>
  I agree to T&C
  <input type="checkbox" id="terms" name="agreeToterms" />
</label>
<select id="veggies" name="selectedVeggie">
  <option value="brinjal">Brinjal</option>
  <option value="tomato">Tomato</option>
  <option value="onion">Onion</option>
</select>
```

```javascript
for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) {
  input.addEventListener("input", (e) => {
    if (e.target.type === "checkbox")
      formData[e.target.name] = e.target.checked;
    else formData[e.target.name] = e.target.value;
  });
}
// more sophisticated code
for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) {
  input.addEventListener("input", ({ target }) => {
    // destructure event object since we only use target
    // destructure more coz we use only these 4 properties in target
    const [name, type, value, checked] = target;
    formData[name] = type === "checkbox" ? checked : value;
  });
}
```

We can add multiple events under single event listener as long as we have `name` attribute.

### change

if we change the above event type to change it will still behave the same except for the textbox. Textbox input change wont trigger until we lose focus over it or press return key after entering complete data or focus it, unlike input where it triggers event for every single key typed(every single letter changed in text box).

```javascript
for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) {
  input.addEventListener("change", ({ target }) => {
    // destructure event object since we only use target
    // destructure more coz we use only these 4 properties in target
    const [name, type, value, checked] = target;
    formData[name] = type === "checkbox" ? checked : value;
  });
}
```

This type of pattern (using name attribute) is pretty common especially if we get to something like **react** and some of the other frameworks or libraries out there. We use **name of an input as a key to store the value from that input** under, to create a nice object that contains all of our form data at once.
