---
id: js14
title: Asynchronous code
sidebar_label: Asynchronous code
---

import useBaseUrl from "@docusaurus/useBaseUrl";

## The call stack

<img alt="call stack" src={useBaseUrl("assets/callstack.png")} />

Call stack is a tool or feature of a JS, helps JS to keep track of where `it` is in your code. If you have multiple functions and some of those may call other functions, using call stack mechanism JS interpreter keeps track of its place. Its how JS knows which function is currently being run and which functions are not done yet. (Last in First Out.)

<img alt="call stack" src={useBaseUrl("assets/csworking.png")} />

Visualized way:

![callstack](https://miro.medium.com/max/1200/1*B2v5_pqD-zbzJNOhAc-A2A.gif)

## JS is single threaded

At any given point in time, that single JS thread is running atmost one line of JS code. Its not multi tasking, it does one thing at a time.

User may not be able to do another task until one is completed.

```javascript
console.log("first");
alert("hi");
console.log("second");
```

you wont get output of 2nd console.log until alert hi is closed.
When we try to access data from a database or an api or trying to save something or to set timer, we cant let user to keep on waiting until we get the data. we have a work around for this **Asynchronous callbacks.**

## How Asynchronous callbacks work?

For the processes that take time we pass a callback function and those functions will be executed at the appropriate time.

Set timer for 3 seconds.

```javascript
console.log("first");
setTimeout(() => {
  console.log("I print after 3 sec");
}, 3000);
console.log("second");
```

But how does JS know to set a timer for 3 seconds if it can only do 1 thing at a time? how does it remember to wait for 3 seconds and call that fn after 3 sec?

The trick here is **The browser does the work**. JS is not same as our browser, it is a language that is implemented in our browser. Generally **_browsers_** like chrome, safari and IE **_are written in a different programming language_** (C++ here for those 3).

Browser itself is capable of doing certain tasks, where JS sucks at or things that take time are handed off to the browser.

:::important
JS is not keeping track of timer , it is not sending an API request. **The browser actually handles it**
:::

### But how does browser do that?

Browsers come with web API that are able to handle certain tasks in the background(like making requests or setTimeOut). The JS call stack recognizes these web API functions and passes themoff to the browser to take care of. Once the browser finishes those tasks they return and are pushed onto the stack as callback.

```javascript
console.log("first"); // ran by javascript
//js passes entire setTimeOut to be run by C++ or the language in which browser is implemented in.
//and continues executing next line of code
setTimeout(function () {
  console.log("I print after 3 sec");
}, 3000);
console.log("second"); // ran by javascript
```

Once the browser finishes of setTimeOut it asks JS to run that callback . It places that callback on the call stack so that JS knows to run that function. JS doesnt keep the time. Same thing with making req, JS doesnt make the req itself the browser and the web api do.

### concurrency and the event loop

The reason why we can do things concurrently is that browser is more than just runtime.

<img
  alt="Async code behind the scenes"
  src={useBaseUrl("assets/asyncArchitecture.png")}
/>

This diagram basically looks identical to Node, instead of Web apis we have c++ apis(coz browser is implemented in c++) and the threading being hidden from us is by c++.

<img alt="concurrency" src={useBaseUrl("assets/concurrency1.png")} />

The setTimeOut api is provided by browser. It doesnt live in V8 source, its the extra we are getting in the environment we are running the javascript

<img alt="concurrency" src={useBaseUrl("assets/concurrency2.png")} />

Now that setTimeOut is out of call stack we can execute other lines of code.

<img alt="concurrency" src={useBaseUrl("assets/concurrency3.png")} />

The timer in web api cant just start modifying our code, it cant chuck stuff on to the stack when its ready if it did, it would randomly appear in middle of the queue. So any of the `webapis pushes the callbacks onto task queue` when its done.

### event loop

Event loop has the one simple job. Its job is to look at the stack and look at the task queue. **If the stack is empty**,it takes the first thing on the queue and pushes it onto the stack which effectively runs it.

:::important
Event loop pushes the callback onto stack, only when its empty.
:::

<img alt="event loop" src={useBaseUrl("assets/event1.png")} />
<img alt="Event loop" src={useBaseUrl("assets/event2.png")} />

:::note
AJAX requests, DOM, Event Listeners, setTimeOut etc are handled by Web APIs. [list of web apis](https://developer.mozilla.org/en-US/docs/Web/API)
:::

> check video on [event loops](https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=youtu.be) for more info.

> To visualize how things work check this [tool](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)
