---
id: js15
title: Making HTTP Requests
sidebar_label: HTTP Requests
---

import useBaseUrl from "@docusaurus/useBaseUrl";

## Types of HTTPRequests

In this section we will explore , how to get information from an api like load movie data, logging into fb or sending data off to your sever to save to db. We send a request from client side. so pre-reqs: async js and promises . Coz most requests take time.

There are multiple ways of making requests

1. XMLHTTP requests
2. Fetch
3. Axios

## AJAX

Before we learn about making requests, lets learn about AJAX(Asynchronous Javascript and XML). These days we mostly work with AJAJ(Asynchronous Javascript and JSON)

Before single page applications came into picture AJAX was the major thing.

If AJAX is used Whenever a new request is made, page reloads. Where as for single page apps, page never reloads when a new request is made.

> Refer [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started)

### JSON and XML

AJAJ and AJAX are two ways of basically formatting data so that we can send it from one server to another server or server to browser.
Although X in Ajax stands for XML, JSON is used more than XML nowadays because of its many advantages such as being lighter and a part of JavaScript. Both JSON and XML are used for packaging information in the Ajax model.

#### XML:

```xml
<name>
    <first>Todd</first>
    <last>Smith</last>
</name>
<email>todd@gmail.com</email>
```

Using javascript we can parse XML to js objects

#### JSON:

Its another notation to send data. every key in json must be strings. we can have value as numbers, boolean, arrays, but not complicated things like functions

### XMLHttpRequest : Basics

- The "original" way of sending requests via JS.
- Doesn't support promises, so.. lots of callbacks! :(
- Clunky syntax -> hard to remember

<img alt="xhrcode" src={useBaseUrl("assets/xhrcode.png")} />

> Learn more about it [here](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)

```javascript
const firstReq = new XMLHttpRequest();
//In the event, if everything works perfectly
firstReq.addEventListener("load", function () {
  //convert the json data which we receive as response to js object
  const data = JSON.parse(this.responseText);
  // print planet names from api
  for (let planet of data.results) {
    console.log(planet.name);
  }
});
//in the event if something fails
firstReq.addEventListener("error", () => {
  console.log("Error!!!");
});
firstReq.open("GET", "https://swapi.dev/api/planets"); // this takes time
firstReq.send(); // request is sent to browser to handle it
console.log("Request sent");
```

There are two ways in which an XMLHttpRequest can fail -

1. We can try to issue a request to a remote web server that doesn't exist
2. We can try to issue a request to a remote web server that does exist, but that server can send is back a response with an error status code.

Now here's the confusing part: a request that fails due to #1 triggers the 'error' event. A request that fails due to #2 does not. It still triggers the 'load' event! This is kind of unexpected, which means that we'd have to inspect the response that comes back, look at the status code, and decide whether the request actually was an error or not.

> Refer [Q/A](https://www.udemy.com/course/javascript-beginners-complete-tutorial/learn/lecture/17178062#questions/8856128)

Access the data that is coming back from server using **this.responseText**

But responseText property in our object 'firstReq' can be huge (It is JSON here) , parse it to javascript using **JSON.parse()**

:::caution
If you want to access `this` inside callback, dont use arrow function as callback
:::

### XMLHttpRequest : Chaining Requests

This is only 2 levels deep, still it looks more complicated.

```javascript
const firstReq = new XMLHttpRequest();
firstReq.addEventListener("load", function () {
  const data = JSON.parse(this.responseText);
  //extract data from planets api, which internally has some other apis
  const filmURL = data.results[0].films[0];
  // to access this we have to write an entire request once again
  const filmReq = new XMLHttpRequest();
  filmReq.addEventListener("load", function () {
    const filmData = JSON.parse(this.responseText);
    console.log(filmData);
  });
  filmReq.addEventListener("error", function (e) {
    console.log("Error", e);
  });
  filmReq.open("GET", filmURL);
  filmReq.send();
});
firstReq.addEventListener("error", function (e) {
  console.log("Error!!!", e);
});
firstReq.open("GET", "https://swapi.dev/api/planets"); // this takes time
firstReq.send(); // request is sent to browser to handle it
console.log("Request sent");
```

---

## A Better way : Fetch!

### Fetch API

1. Newer way of making requests via JS
2. Supports Promises!
3. Not supported in IE :(

The `fetch()` method takes one mandatory argument, the path to the resource you want to fetch. It returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to the [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) to that request, whether it is successful or not. You can also optionally pass in an init options object as the second argument (see [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)).

Syntax:

```javascript
fetch("http://example.com/movies.json")
  .then((response) => response.json())
  .then((data) => console.log(data)); //RT : promise
```

:::note
fetch method returns a promise
:::

```javascript
fetch("https://swapi.dev/api/planets").then((response) => {
  console.log(response);
});

Output:
Response {type: "cors", url: "https://swapi.dev/api/planets/", redirected: true, status: 200, ok: true, …}
body: ReadableStream
locked: false
__proto__: ReadableStream
bodyUsed: false
headers: Headers {}
ok: true
redirected: true
status: 200
statusText: ""
type: "cors"
url: "https://swapi.dev/api/planets/"
__proto__: Response
```

body property : is a readable stream.

ReadableStream is a stream of "byte data". This is one of the key differences from XHR

:::note
Source: MDN
The ReadableStream interface of the Streams API represents a **readable stream of byte data**. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.

Refer [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/Body/body)
:::

#### Body.json():

The json() method of the Body mixin takes a Response stream and reads it to completion. It returns a promise that resolves with the result of parsing the body text as JSON.

RT: A Promise that resolves to a JavaScript object. This object could be anything that can be represented by JSON — an object, an array, a string, a number...

syntax :

```javascript
response.json().then((data) => {
  // do something with your data
}); //RT: Promise
```

Since response.json() returns a promise, use .then or .catch to resolve or reject the promise. (response.json() is async method, it will take a while to load)

```javascript
fetch("https://swapi.dev/api/planets").then((response) => {
  console.log(response.json());
});

Output :
Promise {<pending>}
__proto__: Promise
[[PromiseStatus]]: "resolved"
[[PromiseValue]]: undefined
```

```javascript
fetch("https://swapi.dev/api/planets").then((response) => {
  response.json().then((data) => {
    console.log(data);
  });
});
Output:
Coz our promise is resolved
{count: 60, next: "http://swapi.dev/api/planets/?page=2", previous: null, results: Array(10)}
```

> For more info on [Fetch API](https://developers.google.com/web/updates/2015/03/introduction-to-fetch)

Lets refactor the previous code using fetch

```javascript
//get the list of planet names using fetch api
fetch("https://swapi.dev/api/planets").then((response) => {
  response
    .json()
    .then((data) => {
      for (let planet of data.results) {
        console.log(planet.name);
      }
    })
    .catch((error) => {
      console.log("Something went wrong", error);
    });
});
```

:::important
The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure or if anything prevented the request from completing.
:::

```javascript
fetch("https://swapi.dev/api/planetssakdjhskj").then((response) => {
  response
    .json()
    .then((data) => {
      for (let planet of data.results) {
        console.log(planet.name);
      }
    })
    .catch((error) => {
      console.log("Something went wrong", error);
    });
});

// Output:
// VM88:1 GET https://swapi.dev/api/planetssakdjhskj 404
// (anonymous) @ VM88:1
// VM88:10 Something went wrong SyntaxError: Unexpected token < in JSON at position 1

// Promise got resolved, instead of throwing an error
```

Lets say there was a network failure

error:
This is caught in promise

`VM122:1 GET https://swapi.dev/api/planetssakdjhskj net::ERR_INTERNET_DISCONNECTED`

Before we try and read json, lets make sure we will proceed if only our status code is 200.

```javascript
//1st way
fetch("https://swapi.dev/api/planets")
  .then((response) => {
    if (!response.ok) {
      console.log("Error: Status is not 200", response.status);
    } else {
      response.json().then((data) => {
        for (let planet of data.results) {
          console.log(planet.name);
        }
      });
    }
  })
  .catch((error) => {
    console.log("Something went wrong", error);
  });

//2nd way
//we can also throw an error in .then()

fetch("https://swapi.dev/api/planets")
  .then((response) => {
    if (!response.ok) {
      throw new Error(`status code error :${response.status}`);
    } else {
      response.json().then((data) => {
        for (let planet of data.results) {
          console.log(planet.name);
        }
      });
    }
  })
  .catch((error) => {
    console.log("Something went wrong", error);
  });
```

### Chaining Fetch requests

We can chain the fetch requests one after the other and avoid the messy callback situation previously we had using XHR.

```javascript
fetch("https://swapi.dev/api/planets")
  .then((response) => {
    if (!response.ok) throw new Error(`status code error :${response.status}`);
    //instead of nesting .then inside another .then
    //  return a promise which is returned from response.json() and chain another.then to it
    return response.json();
  })
  .then((data) => {
    console.log("Fetched all planets(first 10)");
    const filmURL = data.results[0].films[0];
    return fetch(filmURL);
  })
  .then((response) => {
    if (!response.ok) throw new Error(`status code error :${response.status}`);
    return response.json();
  })
  .then((data) => {
    console.log("Fetched first film based off of first planet");
    console.log(data.title);
  })
  .catch((error) => {
    console.log("Something went wrong", error);
  });

// Output:
// A new hope
```

### Refactoring fetch Chains

```javascript
const checkStatusAndParse = (response) => {
  if (!response.ok) throw new Error(`status code error :${response.status}`);
  return response.json();
};
const printPlanets = (data) => {
  console.log("Loaded 10 more planets...");
  for (let planet of data.results) {
    console.log(planet.name);
  }
  //two ways to resolve a promise
  //1st way
  return new Promise((resolve, reject) => {
    // resolve with data, because next .then requires the data
    resolve(data);
  });
  //2nd way ->  Promise.resolve() we dont need to go through the clunky syntax
  return Promise.resolve(data);
};
fetch("https://swapi.dev/api/planets")
  .then(checkStatusAndParse)
  .then(printPlanets) //next .then throws an error because we are not returning any promise from printPlanets
  //promise chaining works only when a promise is returned from previous .then
  .then((data) => {
    const nextURL = data.next;
    return fetch(nextURL);
  })
  .then(checkStatusAndParse)
  .then(printPlanets)
  .catch((error) => {
    console.log("Something went wrong", error);
  });
```

Final code..

```javascript
const checkStatusAndParse = (response) => {
  if (!response.ok) throw new Error(`status code error :${response.status}`);
  return response.json();
};
const printPlanets = (data) => {
  console.log("Loaded 10 more planets...");
  for (let planet of data.results) {
    console.log(planet.name);
  }
  return Promise.resolve(data.next); // coz next .then() expects a url
};
//or we can give a url parameter  a default  url and from next time onwards it will pick a data.next
const fetchMorePlanets = (url = "https://swapi.dev/api/planets") => {
  return fetch(url);
};

fetchMorePlanets()
  .then(checkStatusAndParse)
  .then(printPlanets)
  .then(fetchMorePlanets)
  .then(checkStatusAndParse)
  .then(printPlanets)
  .catch((error) => {
    console.log("Something went wrong", error);
  });
```

---

## Even Better way : AXIOS

### Intro

**A library for making HTTP requests**. This is not an inbuilt option.

> [Official repo](https://github.com/axios/axios)

Behind the scenes, axios uses fetch internally. One nice thing about axios is we can use it on both client side(browser) and server side(node.js), which is not true with many other libraries.

Main advantage of axios over fetch is, data is already parsed to javascript for us and status code validity is done, we dont need to parse it externally using response.json()

```javascript
axios.get("https://swapi.dev/api/planets").then((res) => {
  console.log(res.data);
});

// Output:
// {count: 60, next: "http://swapi.dev/api/planets/?page=2", previous: null, results: Array(10)}
// count: 60
// next: "http://swapi.dev/api/planets/?page=2"
// previous: null
// results: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
// __proto__: Object
```

```javascript
axios
  .get("https://swapi.dev/api/planetssdsd")
  .then((res) => {
    console.log(res.data);
  })
  .catch((err) => {
    console.log(err);
  });

//output
// spread.js:25 GET https://swapi.dev/api/planetssdsd 404
// (anonymous) @ spread.js:25
// e.exports @ spread.js:25
// e.exports @ spread.js:25
// Promise.then (async)
// r.request @ spread.js:25
// r.<computed> @ spread.js:25
// (anonymous) @ spread.js:25
// (anonymous) @ app.js:49
// app.js:54 Error: Request failed with status code 404
//     at e.exports (spread.js:25)
//     at e.exports (spread.js:25)
//     at XMLHttpRequest.l.onreadystatechange (spread.js:25)
```

### Sequential Axios Requests

```javascript
const fetchNextPlanet = (url = "https://swapi.dev/api/planets") => {
  return axios.get(url);
};
const printPlanets = ({ data }) => {
  for (let planet of data.results) {
    console.log(planet.name);
  }
  return Promise.resolve(data.next);
};
fetchNextPlanet()
  .then(printPlanets)
  .then(fetchNextPlanet)
  .then(printPlanets)
  .catch((err) => {
    console.log(err);
  });
```
