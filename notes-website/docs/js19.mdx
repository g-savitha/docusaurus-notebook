---
id: js19
title: Callback Hell
sidebar_label: Callback hell
---

import useBaseUrl from "@docusaurus/useBaseUrl";

# Welcome to callback hell

## Intro

<img alt="callback hell" src={useBaseUrl("assets/callbackhell.png")} />

From previous section, we know why callbacks are so important in JS. We pass a callback in to certain functions that the browser takes over.

But callbacks are not perfect, they can get messy very quickly.

```html
<body>
  <button>Move me</button>
  <script src="app.js"></script>
</body>
```

```javascript
const btn = document.querySelector("button");

//using transform makes much faster rendering for browser rather than using top or style attributes.
setTimeout(() => {
  btn.style.transform = `translateX(100px)`; //moves button to right by 100 px
}, 1000);
```

Now lets say i want to move this button 5 levels deeper for every 1 sec. we need to nest this function .

```javascript
setTimeout(() => {
  btn.style.transform = `translateX(100px)`;
  setTimeout(() => {
    btn.style.transform = `translateX(200px)`;
    setTimeout(() => {
      btn.style.transform = `translateX(300px)`;
      setTimeout(() => {
        btn.style.transform = `translateX(400px)`;
        setTimeout(() => {
          btn.style.transform = `translateX(500px)`;
        }, 1000);
      }, 1000);
    }, 1000);
  }, 1000);
}, 1000);
```

lets refactor this...

```javascript
const moveX = (element, amount, delay, callback) => {
  setTimeout(() => {
    element.style.tranform = `translateX(${amount}px)`;
    if (callback) callback();
  }, delay);
};

moveX(btn, 100, 1000, () => {
  moveX(btn, 200, 1000, () => {
    moveX(btn, 300, 1000, () => {
      moveX(btn, 400, 1000, () => {
        moveX(btn, 500, 1000);
      });
    });
  });
});
```

Even this doesnt look much scarier. Lets throw another callback if we move off the screen. previously we had only one branch going down(moveX-> moveX -> moveX ...).

Now we have two call backs for one function. Often this pattern is used we send a http request, if it is success then run one callback, if its a failure run another.

it would look like

```javascript
request(
  () => {
    //onSuccess
  },
  () => {
    //on failure
  }
);
```

## The call back hell example

```javascript
const btn = document.querySelector("button");

//This function moves an element "amount" number of pixels after a delay.
//If the element will stay on screen, we move the element and call the onSuccess callback function
//If the element will move off screen, we do not move the element and instead call the onFailure callback
const moveX = (element, amount, delay, onSuccess, onFailure) => {
  setTimeout(() => {
    const bodyBoundary = document.body.clientWidth;
    const elRight = element.getBoundingClientRect().right;
    const currLeft = element.getBoundingClientRect().left;
    if (elRight + amount > bodyBoundary) {
      onFailure();
    } else {
      element.style.transform = `translateX(${currLeft + amount}px)`;
      onSuccess();
    }
  }, delay);
};

// LOOK AT THIS UGLY MESS!
moveX(
  btn,
  300,
  1000,
  () => {
    //success callback
    moveX(
      btn,
      300,
      1000,
      () => {
        //success callback
        moveX(
          btn,
          300,
          1000,
          () => {
            //success callback
            moveX(
              btn,
              300,
              1000,
              () => {
                //success callback
                moveX(
                  btn,
                  300,
                  1000,
                  () => {
                    //success callback
                    alert("YOU HAVE A WIDE SCREEN!");
                  },
                  () => {
                    //failure callback
                    alert("CANNOT MOVE FURTHER!");
                  }
                );
              },
              () => {
                //failure callback
                alert("CANNOT MOVE FURTHER!");
              }
            );
          },
          () => {
            //failure callback
            alert("CANNOT MOVE FURTHER!");
          }
        );
      },
      () => {
        //failure callback
        alert("CANNOT MOVE FURTHER!");
      }
    );
  },
  () => {
    //failure callback
    alert("CANNOT MOVE FURTHER!");
  }
);
```

This is where promises come in.Promises allow us to rewrite a function like this. we dont have to do all this crazy nesting. it makes more easier to read
