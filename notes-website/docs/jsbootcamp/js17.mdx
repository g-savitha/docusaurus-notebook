---
id: js17
title: Prototypes, classes & The New operator
sidebar_label: Prototypes
---

import useBaseUrl from "@docusaurus/useBaseUrl";

## Prototypes introduction

#### What on earth are prototypes?

**MDN :**

> Prototypes are the mechanism by which JavaScript objects inherit features from one another.

> JavaScript is often described as a prototype-based language — to provide inheritance, objects can have a prototype object, which acts as a template object that it inherits methods and properties from.

What does this mean?

Lets take an eample of Array

<img alt="arrm" src={useBaseUrl("assets/arrmethods.png")} />

all the methods which we use all the time start with Array.prototype

<img alt="arrss1" src={useBaseUrl("assets/arrss1.png")} />

If we look at this array, we dont see any methods over here..

Lets define our own method laugh.

<img alt="arrss2" src={useBaseUrl("assets/arrss2.png")} />

We have a method laugh. When we call push(), we dont see push under our methods.
But push is under **`__proto__`**

`__proto__` is a property that references the array prototype. Prototype is a template object, for in this case arrays. It contains a bunch of methods typically, that all arrays will have access to. Rather than defininig individually for every single array a seperate copy is made. All arrays share a single property called `__proto__`. Prototype is a blue print object.

If you look at `Array.prototype` you have list of all the methods arrays have access to.

We can create our own objects and set its prototype to Array.prototype, now we'll have access to those array methods in our version of the array.

Add our methods to any Object's prototype:

```javascript
String.prototype.angry = () => {
  alert("GO AWAY!!");
};

const cat = "blue";
cat.angry();

/*
String.prototype
String {"", angry: ƒ, constructor: ƒ, anchor: ƒ, big: ƒ, …}
angry: () => { alert("GO AWAY!!"); } // we have our method added to String
anchor: ƒ anchor()
big: ƒ big()
blink: ƒ blink()
bold: ƒ bold()
charAt: ƒ charAt()
charCodeAt: ƒ charCodeAt()
codePointAt: ƒ codePointAt()
concat: ƒ concat()
constructor: ƒ String()*/
```

```javascript
String.prototype.yell = function () {
  console.log(this);
};

"hello".yell();
// output:
// hello -> here `this` refers to our string

String.prototype.yell = function () {
  console.log(this.toUpperCase());
};
//HELLO
String.prototype.yell = function () {
  return `OMG!!!${this.toUpperCase()}!!!`;
};

"get away".yell();

//OMG!!!GET AWAY!!!
```

We can override existing methods

```javascript
Array.prototype.pop = function () {
  return "Sorry i cant pop off that element";
};

[1, 2, 3].pop();
//Sorry i cant pop off that element;
```

### `__proto__` vs Object.Prototype

Object.Prototype here Array.Prototype is an actual object where we add methods or the properties to. This is the template object

`__proto__` is a reference to the Prototype [Array.Prototype object], its a property name under a particular array or String or object.

**MDN:**

> It's important to understand that there is a distinction between an object's prototype (available via Object.getPrototypeOf(obj), or via the deprecated `__proto__` property) and the prototype property on constructor functions.

> The former is the property on each instance, and the latter is the property on the constructor. That is, Object.getPrototypeOf(new Foobar()) refers to the same object as Foobar.prototype

---

## Factory Functions

```javascript
function hex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function rgb(r, g, b) {
  return `(${r}, ${g}, ${b})`;
}
```

Lets write a factory function, which would make an object that automatically had a hex method and an rgb method.

```javascript
//convert rgb to hex
function makeColor(r, g, b) {
  const color = {};
  color.r = r;
  color.g = g;
  color.b = b;
  //since we store these methods in an object we  dont need to pass the parameters
  //object already have r,g,b values.. we can use them
  color.rgb = function () {
    const { r, g, b } = this;
    return `(${r}, ${g}, ${b})`;
  };
  color.hex = function () {
    const { r, g, b } = this;
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  };
  return color;
}
const firstColor = makeColor(35, 255, 150);
firstColor.hex();
```

<img alt="factoryfunc" src={useBaseUrl("assets/factoryfunc.png")} />

If you observe, functions hex and rgb are add to only this object. they are not added to the prototype.

A unique copy is added to each color object. Each color has its own rgb functions. We necessarily dont need to have a unique copy of method to each object, we can reuse the one from prototype

This method is not as ideal as it could be.

---

## Constructor functions

Why constructor functions are used instead of factory functions?

Problem with factory functions?

Objects have their own copy of functions

```javascript
const firstColor = makeColor(35, 255, 150);
firstColor.hex();

const black = makeColor(0, 0, 0);
black.hex();

black.hex === firstColor.hex; // false -> both are not referencing to same method.
//hex method is unique for each object

//example2
"hi".slice === "bye".slice; //true
//here both string refer to same method. Hence we get true
//methods are not created uniquely for each string over here - instead they are defined over prototype
```

This is where construction function comes in

1. Starts with a caps value.
2. Doesn't have a return type.
3. Gets invoked when called with **new** operator.

```javascript
function Color(r, g, b) {
  this.r = r;
  this.g = g;
  this.b = b;
  console.log(this); //window scope -> nearest object
}
```

### new keyword

- Creates a blank, plain JavaScript object;
- Links (sets the constructor of) this object to another object;
- Passes the newly created object from Step 1 as the `this` context;
- Returns `this` if the function doesn't return an object.

```javascript
new Color(255, 40, 100);
//internally performs all the above 4 operations.
```

If you look at `__proto__` we have a constructor property set to color.

Now we can add the methods to prototype.

```javascript
Color.prototype.rgb = function () {
  const { r, g, b } = this;
  return `(${r}, ${g}, ${b})`;
};
// we have access to `this` inside  the function

Color.prototype.hex = function () {
  const { r, g, b } = this;
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
};

const color1 = new Color(255, 40, 100);
const color2 = new Color(50, 90, 115);
//this will be set to color1 and color2

color1.hex === color2.hex; //true
```

<img alt="constructorfn" src={useBaseUrl("assets/constructorfn.png")} />

Now if you observe hex and rgb are under `__proto__`

:::note
If you didn't write the `new` operator, **_the Constructor Function would be invoked like any Regular Function_**, without creating an Object. In this case, the value of `this` is also different.
:::

:::caution
Do not use arrow functions as constructor functions, because they dont have prototype property and also we cant access `this` in arrow functions
:::

> For in depth information refer [Prototype Chain and Inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#Using_prototypes_in_JavaScript)

---

## JS Classes - Syntactical Sugar

Lets see an even better way of writing the above logic

Using class, we dont need to add constructor functions manually.

We always add a constructor in every class. Constructor gets called immediately whenever we invoke with `new` operator.

```javascript
class Color {
  constructor(r, g, b, name) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.name = name;
  }
  innerRGB() {
    const { r, g, b } = this;
    return `${r}, ${g}, ${b})`;
  }
  rgb() {
    return `rgb(${this.innerRGB()})`;
  }
  rgba(a = 1.0) {
    return `rgba(${this.innerRGB()}, ${a})`;
  }
  hex() {
    const { r, g, b } = this;
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }
}

const red = new Color(255, 67, 89, "tomato");
const white = new Color(255, 255, 255, "white");
```

---

## Extends, super, subclasses

Extends:

```javascript
class Pet {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  eat() {
    return `${this.name} is eating`;
  }
}

class Cat extends Pet {
  meow() {
    return "Meow";
  }
}

class Dog extends Pet {
  bark() {
    return "Woof";
  }
}

const wyatt = new Dog("wyatt", 9);
const monty = new Cat("monty", 10);
monty.eat(); // monty is eating
wyatt.eat(); //wyatt scarfs his food -> takes its own version of eat, when its not there, looks for super class
```

Super:

Lets say my cat has an extra property livesleft

```javascript
class Pet {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  eat() {
    return `${this.name} is eating`;
  }
}

class Cat extends Pet {
  constructor(name, age, livesLeft = 9) {
    this.name = name;
    this.age = age;
    this.livesLeft = livesLeft;
  }
  meow() {
    return "Meow";
  }
}
```

Insetad of duplicating use super.

```javascript
class Cat extends Pet {
  constructor(name, age, livesLeft = 9) {
    super(name, age); // calls the constructor of parent class
    //super is a refernce to super class
    this.livesLeft = livesLeft;
  }
  meow() {
    return "Meow";
  }
}
```
